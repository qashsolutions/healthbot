// Convert to FormData for Sarvam API
    const formData = new FormData();import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

// Types
interface User {
  id: string
  chat_id: string
  language: string
  language_name: string
  state: string
  onboarding_info: string
  plan_type: string
  usage_count: number
  daily_usage_count: number
  last_used: string
  created_at: string
  free_complex_used: boolean
  paid_complex_count: number
  pending_query?: string
}

interface TelegramUpdate {
  update_id: number
  message?: {
    message_id: number
    from: {
      id: number
      first_name: string
      last_name?: string
    }
    chat: {
      id: number
      type: string
    }
    date: number
    text?: string
    voice?: {
      file_id: string
      file_unique_id: string
      duration: number
      mime_type: string
      file_size: number
    }
    photo?: Array<{
      file_id: string
      file_unique_id: string
      width: number
      height: number
      file_size?: number
    }>
    document?: {
      file_id: string
      file_unique_id: string
      file_name?: string
      mime_type?: string
      file_size?: number
    }
  }
  callback_query?: {
    id: string
    from: {
      id: number
      first_name: string
    }
    message: {
      message_id: number
      chat: {
        id: number
        type: string
      }
    }
    data: string
  }
}

// Initialize Supabase client
const supabaseUrl = 'https://sqnbeyvilpbpngffkueg.supabase.co'
const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
const supabase = createClient(supabaseUrl, supabaseKey)

// Bot configuration
const BOT_TOKEN = Deno.env.get('TELEGRAM_BOT_TOKEN')!
const OPENAI_API_KEY = Deno.env.get('OPENAI_API_KEY')!
const GEMINI_API_KEY = Deno.env.get('GEMINI_API_KEY')!
const SARVAM_API_KEY = Deno.env.get('SARVAM_API_KEY')!

// Language mapping for callback data
const LANGUAGE_CALLBACKS = {
  'lang_hi': { code: 'hi-IN', name: 'Hindi', sarvam: 'hi' },
  'lang_en': { code: 'en-IN', name: 'English', sarvam: 'en' },
  'lang_ta': { code: 'ta-IN', name: 'Tamil', sarvam: 'ta' },
  'lang_te': { code: 'te-IN', name: 'Telugu', sarvam: 'te' },
  'lang_kn': { code: 'kn-IN', name: 'Kannada', sarvam: 'kn' },
  'lang_ml': { code: 'ml-IN', name: 'Malayalam', sarvam: 'ml' },
  'lang_bn': { code: 'bn-IN', name: 'Bengali', sarvam: 'bn' },
  'lang_gu': { code: 'gu-IN', name: 'Gujarati', sarvam: 'gu' },
  'lang_mr': { code: 'mr-IN', name: 'Marathi', sarvam: 'mr' },
  'lang_pa': { code: 'pa-IN', name: 'Punjabi', sarvam: 'pa' }
}

// User management functions
async function getOrCreateUser(chatId: string): Promise<User> {
  try {
    let { data: user, error } = await supabase
      .from('users')
      .select('*')
      .eq('chat_id', chatId)
      .single()

    if (error && error.code === 'PGRST116') {
      const { data: newUser, error: createError } = await supabase
        .from('users')
        .insert([{
          chat_id: chatId,
          created_at: new Date().toISOString(),
          state: 'language_selection',
          usage_count: 0,
          plan_type: 'free',
          free_complex_used: false,
          paid_complex_count: 0
        }])
        .select()
        .single()

      if (createError) throw createError
      return newUser as User
    }

    if (error) throw error
    return user as User
  } catch (err) {
    console.error('Error in getOrCreateUser:', err)
    throw err
  }
}

async function updateUserState(chatId: string, updates: any) {
  const { data, error } = await supabase
    .from('users')
    .update(updates)
    .eq('chat_id', chatId)
  
  if (error) throw error
  return data
}

// Sarvam API functions
async function transcribeAudio(audioUrl: string, userLanguage: string): Promise<string> {
  try {
    console.log(`üé§ Transcribing audio with Sarvam STT`);
    
    // Download audio file
    const audioResponse = await fetch(audioUrl);
    const audioArrayBuffer = await audioResponse.arrayBuffer();
    
    // Create blob with proper OGG audio type
    const audioBlob = new Blob([audioArrayBuffer], { type: 'audio/ogg' });
    
    // Convert to FormData for Sarvam API
    const formData = new FormData();
    formData.append('file', audioBlob, 'audio.ogg');
    formData.append('model', 'saarika:v2.5');
    
    const response = await fetch('https://api.sarvam.ai/speech-to-text', {
      method: 'POST',
      headers: {
        'api-subscription-key': SARVAM_API_KEY
      },
      body: formData
    });
    
    const result = await response.json();
    console.log('Sarvam STT response:', JSON.stringify(result));
    
    // Based on Sarvam docs, response structure is { "transcript": "text" }
    if (result.transcript) {
      console.log(`‚úÖ STT Success: "${result.transcript}"`);
      return result.transcript;
    } else {
      console.error('No transcript in response:', result);
      throw new Error('No transcript returned from Sarvam API');
    }
  } catch (error) {
    console.error('Sarvam STT error:', error);
    throw error;
  }
}

async function translateText(text: string, fromLang: string, toLang: string): Promise<string> {
  try {
    console.log(`üåê Translating: ${fromLang} ‚Üí ${toLang}`);
    
    const response = await fetch('https://api.sarvam.ai/translate', {
      method: 'POST',
      headers: {
        'API-Subscription-Key': SARVAM_API_KEY,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        input: text,
        source_language_code: fromLang,
        target_language_code: toLang,
        speaker_gender: 'Female',
        mode: 'formal',
        model: 'mayura:v1',
        enable_preprocessing: true
      })
    });
    
    const result = await response.json();
    
    if (result.translated_text) {
      console.log(`‚úÖ Translation: "${result.translated_text}"`);
      return result.translated_text;
    } else {
      console.error('No translation in response:', result);
      return text; // Fallback to original text
    }
  } catch (error) {
    console.error('Sarvam translation error:', error);
    return text; // Fallback to original text
  }
}

async function generateAudio(text: string, language: string): Promise<ArrayBuffer> {
  try {
    console.log(`üîä Generating audio with Sarvam TTS`);
    
    // Limit text to 500 characters per Sarvam docs
    const limitedText = text.length > 500 ? text.substring(0, 500) + '...' : text;
    
    const response = await fetch('https://api.sarvam.ai/text-to-speech', {
      method: 'POST',
      headers: {
        'api-subscription-key': SARVAM_API_KEY,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        text: limitedText,
        target_language_code: language,
        speaker: 'meera',
        pitch: 0,
        pace: 1.65,
        loudness: 1.5,
        speech_sample_rate: 8000,
        enable_preprocessing: true,
        model: 'bulbul:v1'
      })
    });
    
    if (response.ok) {
      const audioBuffer = await response.arrayBuffer();
      console.log(`‚úÖ TTS Success: Generated ${audioBuffer.byteLength} bytes`);
      return audioBuffer;
    } else {
      const errorText = await response.text();
      console.error('TTS API error:', response.status, errorText);
      throw new Error(`TTS API error: ${response.status}`);
    }
  } catch (error) {
    console.error('Sarvam TTS error:', error);
    throw error;
  }
}

// MAI-DxO Orchestrator - Multi-Agent Diagnostic System
async function maiDxoOrchestrator(query: string, userContext: any): Promise<string> {
  try {
    console.log(`ü§ñ Starting MAI-DxO orchestrator for query: "${query}"`);
    
    // Virtual panel of 5 specialist physicians
    const specialists = [
      { role: "Dr. Hypothesis", focus: "differential diagnosis with probability ranking" },
      { role: "Dr. Test-Chooser", focus: "selecting optimal diagnostic tests" },
      { role: "Dr. Challenger", focus: "identifying bias and contradictory evidence" },
      { role: "Dr. Synthesizer", focus: "integrating all findings" },
      { role: "Dr. Cost-Optimizer", focus: "minimizing unnecessary tests" }
    ];

    const responses = [];
    
    // Get responses from multiple AI models (ensemble approach)
    console.log(`üì° Getting Claude response...`);
    const claudeResponse = await getClaudeResponse(query, userContext, specialists);
    responses.push(claudeResponse);
    
    console.log(`üì° Getting OpenAI response...`);
    const openaiResponse = await getOpenAIResponse(query, userContext, specialists);
    responses.push(openaiResponse);
    
    console.log(`üì° Getting Gemini response...`);
    const geminiResponse = await getGeminiResponse(query, userContext, specialists);
    responses.push(geminiResponse);
    
    // Synthesize final diagnosis from all models
    console.log(`üî¨ Synthesizing final diagnosis...`);
    const finalDiagnosis = await synthesizeDiagnosis(responses, query, userContext);
    
    return finalDiagnosis;
  } catch (error) {
    console.error('Error in MAI-DxO:', error);
    // Fallback to Claude only if multi-AI fails
    return await getHealthResponse(query, userContext);
  }
}

async function getClaudeResponse(query: string, context: any, specialists: any[]): Promise<string> {
  const prompt = `You are part of a virtual medical panel. ${specialists.map(s => s.role + ": " + s.focus).join(", ")}
  
Patient query: ${query}
Context: ${JSON.stringify(context)}

Provide structured analysis:
1. DIFFERENTIAL DIAGNOSIS (top 3 with probabilities)
2. RECOMMENDED TESTS (most informative, cost-effective)
3. RISK ASSESSMENT
4. NEXT STEPS

Be thorough but cost-conscious.`;

  return await getHealthResponse(prompt, context);
}

async function getOpenAIResponse(query: string, context: any, specialists: any[]): Promise<string> {
  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${OPENAI_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: 'gpt-4o',
        messages: [
          {
            role: 'system',
            content: 'You are a specialist physician in a diagnostic panel. Provide detailed medical analysis with differential diagnosis, test recommendations, and cost considerations.'
          },
          {
            role: 'user',
            content: `Patient query: ${query}\nContext: ${JSON.stringify(context)}`
          }
        ],
        max_tokens: 1000
      })
    });
    
    const result = await response.json();
    
    // Better error handling
    if (result.error) {
      console.error('OpenAI API error:', result.error);
      return 'OpenAI analysis unavailable: ' + result.error.message;
    }
    
    if (!result.choices || !result.choices[0] || !result.choices[0].message) {
      console.error('OpenAI unexpected response structure:', result);
      return 'OpenAI analysis unavailable: unexpected response';
    }
    
    return result.choices[0].message.content;
  } catch (error) {
    console.error('OpenAI API error:', error);
    return 'OpenAI analysis unavailable';
  }
}

async function getGeminiResponse(query: string, context: any, specialists: any[]): Promise<string> {
  try {
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: `As a medical specialist, analyze this case: ${query}\nContext: ${JSON.stringify(context)}\nProvide differential diagnosis, test recommendations, and cost analysis.`
          }]
        }]
      })
    });
    
    const result = await response.json();
    
    // Better error handling
    if (result.error) {
      console.error('Gemini API error:', result.error);
      return 'Gemini analysis unavailable: ' + result.error.message;
    }
    
    if (!result.candidates || !result.candidates[0] || !result.candidates[0].content || !result.candidates[0].content.parts || !result.candidates[0].content.parts[0]) {
      console.error('Gemini unexpected response structure:', result);
      return 'Gemini analysis unavailable: unexpected response';
    }
    
    return result.candidates[0].content.parts[0].text;
  } catch (error) {
    console.error('Gemini API error:', error);
    return 'Gemini analysis unavailable';
  }
}

async function synthesizeDiagnosis(responses: string[], query: string, context: any): Promise<string> {
  const synthesisPrompt = `You are the lead physician synthesizing opinions from a medical panel.

Panel responses:
${responses.map((r, i) => `Specialist ${i + 1}: ${r}`).join('\n\n')}

Original query: ${query}

Synthesize into a final diagnostic assessment:
1. CONSENSUS DIAGNOSIS with confidence level
2. KEY TESTS RECOMMENDED (prioritized by value)
3. IMMEDIATE ACTIONS
4. COST ESTIMATE
5. FOLLOW-UP PLAN

‚ö†Ô∏è IMPORTANT: This is advanced AI analysis. Always consult qualified medical professionals for actual diagnosis and treatment.

Credit: This analysis uses Microsoft's MAI-DxO methodology (Sequential Diagnosis with Language Models, Nori et al., 2025)`;

  return await getHealthResponse(synthesisPrompt, context);
}

// Claude AI function
async function getHealthResponse(query: string, userContext: any = {}, wordLimit?: number): Promise<string> {
  try {
    const wordLimitInstruction = wordLimit ? `\n\nIMPORTANT: Limit your response to exactly ${wordLimit} words or less.` : '';
    
    const systemPrompt = `You are a helpful healthcare assistant for Indian users. Provide medical guidance but always include disclaimers to consult healthcare professionals. Keep responses concise but informative.

User context: ${JSON.stringify(userContext)}

Structure your response as:
1. Brief assessment
2. Recommendations  
3. Important disclaimer

Always end with: "‚ö†Ô∏è This is general guidance only. Please consult a qualified doctor for proper diagnosis and treatment."${wordLimitInstruction}`

    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'x-api-key': Deno.env.get('CLAUDE_API_KEY')!,
        'Content-Type': 'application/json',
        'anthropic-version': '2023-06-01',
        'Cache-Control': 'no-cache'
      },
      body: JSON.stringify({
        model: 'claude-sonnet-4-20250514',
        max_tokens: wordLimit ? Math.min(wordLimit * 2, 300) : 1000,
        messages: [
          {
            role: 'user',
            content: `${query} [${Date.now()}]`
          }
        ],
        system: systemPrompt
      })
    })
    
    const result = await response.json()
    
    // Handle potential API errors
    if (result.error) {
      throw new Error(`Claude API error: ${result.error.message}`)
    }
    
    // Return content safely
    return result.content?.[0]?.text || 'Unable to process request'
  } catch (error) {
    console.error('Error calling Claude API:', error)
    // Return fallback message
    return 'I apologize, but I\'m experiencing technical difficulties. Please try again in a moment. ‚ö†Ô∏è This is general guidance only. Please consult a qualified doctor for proper diagnosis and treatment.'
  }
}

// Helper function to check if complex diagnosis is needed
function shouldUseMaiDxo(query: string, isVoice: boolean, isImage: boolean, user: User): boolean {
  const complexKeywords = [
    'diagnosis', 'diagnose', 'symptoms', 'disease', 'condition',
    'multiple symptoms', 'chronic', 'severe', 'urgent', 'emergency',
    'test', 'examination', 'specialist', 'treatment plan', 'chest pain',
    'shortness of breath', 'heart attack', 'stroke', 'bleeding', 'fever',
    'headache', 'stomach pain', 'back pain', 'dizziness', 'nausea'
  ];
  
  const lowerQuery = query.toLowerCase();
  const hasKeywords = complexKeywords.some(keyword => lowerQuery.includes(keyword));
  const isLongQuery = query.length > 100;
  const isComplex = hasKeywords || isLongQuery || isVoice || isImage;
  
  console.log(`üîç DIAGNOSIS TYPE CHECK:`);
  console.log(`Query: "${query}"`);
  console.log(`Complex: ${isComplex}`);
  console.log(`Reasons: Keywords=${hasKeywords}, Length=${isLongQuery}, Voice=${isVoice}, Image=${isImage}`);
  console.log(`User usage: ${user.usage_count}/10 free questions used`);
  
  return isComplex;
}

// Language keyboard helper
function getLanguageInlineKeyboard() {
  return {
    inline_keyboard: [
      [
        { text: "üáÆüá≥ Hindi (‡§π‡§ø‡§Ç‡§¶‡•Ä)", callback_data: "lang_hi" },
        { text: "üá¨üáß English", callback_data: "lang_en" }
      ],
      [
        { text: "Tamil (‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç)", callback_data: "lang_ta" },
        { text: "Telugu (‡∞§‡±Ü‡∞≤‡±Å‡∞ó‡±Å)", callback_data: "lang_te" }
      ],
      [
        { text: "Kannada (‡≤ï‡≤®‡≥ç‡≤®‡≤°)", callback_data: "lang_kn" },
        { text: "Malayalam (‡¥Æ‡¥≤‡¥Ø‡¥æ‡¥≥‡¥Ç)", callback_data: "lang_ml" }
      ],
      [
        { text: "Bengali (‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ)", callback_data: "lang_bn" },
        { text: "Gujarati (‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä)", callback_data: "lang_gu" }
      ],
      [
        { text: "Marathi (‡§Æ‡§∞‡§æ‡§†‡•Ä)", callback_data: "lang_mr" },
        { text: "Punjabi (‡®™‡©∞‡®ú‡®æ‡®¨‡©Ä)", callback_data: "lang_pa" }
      ]
    ]
  };
}

// Clear conversation history for fresh responses
async function clearUserContext(chatId: string) {
  console.log(`üîÑ Clearing context for user ${chatId}`);
  await updateUserState(chatId, {
    last_used: new Date().toISOString()
  });
}

// Show main menu
async function showMainMenu(chatId: string, user: User) {
  const menuMessages: Record<string, string> = {
    'hi': 'üìã **‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§Æ‡•á‡§®‡•Ç**\n\nü©∫ **DR247 AI ‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§∏‡§π‡§æ‡§Ø‡§ï**',
    'ta': 'üìã **‡ÆÆ‡ØÅ‡Æ§‡Æ©‡Øç‡ÆÆ‡Øà ‡ÆÆ‡ØÜ‡Æ©‡ØÅ**\n\nü©∫ **DR247 AI ‡Æâ‡Æü‡Æ≤‡Øç‡Æ®‡Æ≤ ‡Æâ‡Æ§‡Æµ‡Æø‡ÆØ‡Ææ‡Æ≥‡Æ∞‡Øç**',
    'te': 'üìã **‡∞™‡±ç‡∞∞‡∞ß‡∞æ‡∞® ‡∞Æ‡±Ü‡∞®‡±Ç**\n\nü©∫ **DR247 AI ‡∞Ü‡∞∞‡±ã‡∞ó‡±ç‡∞Ø ‡∞∏‡∞π‡∞æ‡∞Ø‡∞ï‡±Å‡∞°‡±Å**',
    'kn': 'üìã **‡≤Æ‡≥Å‡≤ñ‡≥ç‡≤Ø ‡≤Æ‡≥Ü‡≤®‡≥Å**\n\nü©∫ **DR247 AI ‡≤Ü‡≤∞‡≥ã‡≤ó‡≥ç‡≤Ø ‡≤∏‡≤π‡≤æ‡≤Ø‡≤ï**',
    'ml': 'üìã **‡¥™‡µç‡¥∞‡¥ß‡¥æ‡¥® ‡¥Æ‡µÜ‡¥®‡µÅ**\n\nü©∫ **DR247 AI ‡¥Ü‡¥∞‡µã‡¥ó‡µç‡¥Ø ‡¥∏‡¥π‡¥æ‡¥Ø‡¥ø**',
    'bn': 'üìã **‡¶™‡ßç‡¶∞‡¶ß‡¶æ‡¶® ‡¶Æ‡ßá‡¶®‡ßÅ**\n\nü©∫ **DR247 AI ‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø ‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶ï**',
    'gu': 'üìã **‡™Æ‡´Å‡™ñ‡´ç‡™Ø ‡™Æ‡´á‡™®‡´Å**\n\nü©∫ **DR247 AI ‡™Ü‡™∞‡´ã‡™ó‡´ç‡™Ø ‡™∏‡™π‡™æ‡™Ø‡™ï**',
    'mr': 'üìã **‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§Æ‡•á‡§®‡•Ç**\n\nü©∫ **DR247 AI ‡§Ü‡§∞‡•ã‡§ó‡•ç‡§Ø ‡§∏‡§π‡§æ‡§Ø‡•ç‡§Ø‡§ï**',
    'pa': 'üìã **‡®Æ‡©Å‡©±‡®ñ ‡®Æ‡©Ä‡®®‡©Ç**\n\nü©∫ **DR247 AI ‡®∏‡®ø‡®π‡®§ ‡®∏‡®π‡®æ‡®á‡®ï**',
    'en': 'üìã **MAIN MENU**\n\nü©∫ **DR247 AI HEALTH ASSISTANT**'
  };

  const menuMsg = menuMessages[user.language] || menuMessages['en'];

  const keyboard = {
    keyboard: [
      [{ text: 'üí¨ Health Question' }, { text: 'üíä Find Medicine Store' }],
      [{ text: 'üì∏ Scan Report' }, { text: 'üåê Language' }],
      [{ text: 'üìä Usage Stats' }, { text: '‚ùì Help' }]
    ],
    resize_keyboard: true,
    persistent: true
  };

  await sendTelegramMessage(chatId, menuMsg, { reply_markup: keyboard });
}

// Telegram messaging functions
async function sendTelegramMessage(chatId: string, text: string, replyMarkup?: any) {
  try {
    const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        chat_id: chatId,
        text: text,
        reply_markup: replyMarkup
      })
    })
    
    if (!response.ok) {
      throw new Error(`Telegram API error: ${response.status}`)
    }
  } catch (error) {
    console.error('Error sending Telegram message:', error)
  }
}

async function sendTelegramAudio(chatId: string, audioBuffer: ArrayBuffer, caption?: string) {
  try {
    const formData = new FormData();
    formData.append('chat_id', chatId);
    formData.append('audio', new Blob([audioBuffer], { type: 'audio/wav' }), 'response.wav');
    if (caption) formData.append('caption', caption);

    const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendAudio`, {
      method: 'POST',
      body: formData
    });

    if (!response.ok) {
      throw new Error(`Telegram audio API error: ${response.status}`);
    }
  } catch (error) {
    console.error('Error sending Telegram audio:', error);
  }
}

async function answerCallbackQuery(callbackQueryId: string, text?: string) {
  try {
    await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/answerCallbackQuery`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        callback_query_id: callbackQueryId,
        text: text || ''
      })
    })
  } catch (error) {
    console.error('Error answering callback query:', error)
  }
}

async function downloadTelegramFile(fileId: string): Promise<string> {
  try {
    // Get file path
    const fileResponse = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/getFile?file_id=${fileId}`)
    const fileData = await fileResponse.json()
    
    if (!fileData.ok) {
      throw new Error('Failed to get file info')
    }
    
    // Download file
    const downloadUrl = `https://api.telegram.org/file/bot${BOT_TOKEN}/${fileData.result.file_path}`
    return downloadUrl
  } catch (error) {
    console.error('Error downloading file:', error)
    throw error
  }
}

// Message templates
function getLanguageSelectionMessage(): string {
  return `üè• Welcome to Dr247 AI Health Assistant!

Please select your preferred language:
1Ô∏è‚É£ Hindi (‡§π‡§ø‡§Ç‡§¶‡•Ä)
2Ô∏è‚É£ English
3Ô∏è‚É£ Tamil (‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç)
4Ô∏è‚É£ Telugu (‡∞§‡±Ü‡∞≤‡±Å‡∞ó‡±Å)
5Ô∏è‚É£ Kannada (‡≤ï‡≤®‡≥ç‡≤®‡≤°)
6Ô∏è‚É£ Malayalam (‡¥Æ‡¥≤‡¥Ø‡¥æ‡¥≥‡¥Ç)
7Ô∏è‚É£ Bengali (‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ)
8Ô∏è‚É£ Gujarati (‡™ó‡ßÅ‡¶ú‡™∞‡™æ‡¶§‡ßÄ)
9Ô∏è‚É£ Marathi (‡§Æ‡§∞‡§æ‡§†‡•Ä)
üîü Punjabi (‡®™‡©∞‡®ú‡®æ‡®¨‡©Ä)

Reply with the number of your choice or use the buttons below.`
}

function getOnboardingMessage(language: string): string {
  const messages: Record<string, string> = {
    'hi': '‡§ï‡•É‡§™‡§Ø‡§æ ‡§®‡§ø‡§Æ‡•ç‡§®‡§≤‡§ø‡§ñ‡§ø‡§§ ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§∏‡§æ‡§ù‡§æ ‡§ï‡§∞‡•á‡§Ç:\n1. ‡§Ü‡§™‡§ï‡•Ä ‡§â‡§Æ‡•ç‡§∞\n2. ‡§≤‡§ø‡§Ç‡§ó (‡§™‡•Å‡§∞‡•Å‡§∑/‡§Æ‡§π‡§ø‡§≤‡§æ/‡§Ö‡§®‡•ç‡§Ø)\n3. ‡§ï‡•ã‡§à ‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ\n\n‡§â‡§¶‡§æ‡§π‡§∞‡§£: "35 ‡§∏‡§æ‡§≤, ‡§™‡•Å‡§∞‡•Å‡§∑, ‡§°‡§æ‡§Ø‡§¨‡§ø‡§ü‡•Ä‡§ú ‡§î‡§∞ ‡§π‡§æ‡§à BP"',
    'en': 'Please share the following information:\n1. Your age\n2. Gender (Male/Female/Other)\n3. Any major health conditions\n\nExample: "35 years, Male, Diabetes and High BP"',
    'ta': '‡Æ§‡ÆØ‡Æµ‡ØÅ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡ØÅ ‡Æ™‡Æø‡Æ©‡Øç‡Æµ‡Æ∞‡ØÅ‡ÆÆ‡Øç ‡Æ§‡Æï‡Æµ‡Æ≤‡Øç‡Æï‡Æ≥‡Øà‡Æ™‡Øç ‡Æ™‡Æï‡Æø‡Æ∞‡Æµ‡ØÅ‡ÆÆ‡Øç:\n1. ‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æµ‡ÆØ‡Æ§‡ØÅ\n2. ‡Æ™‡Ææ‡Æ≤‡Æø‡Æ©‡ÆÆ‡Øç (‡ÆÜ‡Æ£‡Øç/‡Æ™‡ØÜ‡Æ£‡Øç/‡ÆÆ‡Æ±‡Øç‡Æ±‡Æµ‡Øà)\n3. ‡Æè‡Æ§‡Øá‡Æ©‡ØÅ‡ÆÆ‡Øç ‡ÆÆ‡ØÅ‡Æï‡Øç‡Æï‡Æø‡ÆØ ‡Æâ‡Æü‡Æ≤‡Øç‡Æ®‡Æ≤‡Æ™‡Øç ‡Æ™‡Æø‡Æ∞‡Æö‡Øç‡Æö‡Æø‡Æ©‡Øà‡Æï‡Æ≥‡Øç',
    'te': '‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø ‡∞à ‡∞ï‡±ç‡∞∞‡∞ø‡∞Ç‡∞¶‡∞ø ‡∞∏‡∞Æ‡∞æ‡∞ö‡∞æ‡∞∞‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞™‡∞Ç‡∞ö‡±Å‡∞ï‡±ã‡∞Ç‡∞°‡∞ø:\n1. ‡∞Æ‡±Ä ‡∞µ‡∞Ø‡∞∏‡±ç‡∞∏‡±Å\n2. ‡∞≤‡∞ø‡∞Ç‡∞ó‡∞Ç (‡∞™‡±Å‡∞∞‡±Å‡∞∑‡±Å‡∞°‡±Å/‡∞∏‡±ç‡∞§‡±ç‡∞∞‡±Ä/‡∞á‡∞§‡∞∞)\n3. ‡∞è‡∞µ‡±à‡∞®‡∞æ ‡∞™‡±ç‡∞∞‡∞ß‡∞æ‡∞® ‡∞Ü‡∞∞‡±ã‡∞ó‡±ç‡∞Ø ‡∞∏‡∞Æ‡∞∏‡±ç‡∞Ø‡∞≤‡±Å'
  }
  
  return messages[language] || messages['en']
}

// Message handlers
async function handleLanguageSelection(chatId: string, messageText: string, user: User) {
  const choice = messageText.trim().replace(/[^\d]/g, '') // Remove all non-digits
  const languageMap: Record<string, keyof typeof LANGUAGE_CALLBACKS> = {
    '1': 'lang_hi',
    '2': 'lang_en',
    '3': 'lang_ta',
    '4': 'lang_te',
    '5': 'lang_kn',
    '6': 'lang_ml',
    '7': 'lang_bn',
    '8': 'lang_gu',
    '9': 'lang_mr',
    '10': 'lang_pa'
  }
  
  console.log(`üîç Language selection - Raw input: "${messageText}", Cleaned: "${choice}"`);
  
  const languageKey = languageMap[choice]
  const language = languageKey ? LANGUAGE_CALLBACKS[languageKey] : null
  
  if (!language) {
    console.log(`‚ùå Invalid language choice: "${choice}"`);
    const keyboard = getLanguageInlineKeyboard()
    await sendTelegramMessage(chatId, '‚ùå **INVALID CHOICE!**\n\nüëÜ **TAP A BUTTON BELOW OR TYPE 1-10:**', keyboard)
    return
  }
  
  console.log(`‚úÖ Valid language selected: ${language.name}`);
  await updateUserState(chatId, {
    language: language.sarvam,
    language_name: language.name,
    state: 'onboarding'
  })
  
  const onboardingMsg = getOnboardingMessage(language.sarvam)
  await sendTelegramMessage(chatId, onboardingMsg)
}

async function handleCallbackQuery(callbackQuery: any) {
  const chatId = callbackQuery.message.chat.id.toString()
  const data = callbackQuery.data
  
  // Answer the callback query to stop loading animation
  await answerCallbackQuery(callbackQuery.id)
  
  try {
    const user = await getOrCreateUser(chatId)
    
    if (data.startsWith('lang_')) {
      const language = LANGUAGE_CALLBACKS[data as keyof typeof LANGUAGE_CALLBACKS]
      
      if (language) {
        await updateUserState(chatId, {
          language: language.sarvam,
          language_name: language.name,
          state: 'onboarding'
        })
        
        const onboardingMsg = getOnboardingMessage(language.sarvam)
        await sendTelegramMessage(chatId, onboardingMsg)
      }
    } else if (data === 'use_simple') {
      // Handle using simple diagnosis instead of complex
      if (user.pending_query) {
        console.log(`üí¨ User ${chatId} chose simple diagnosis over complex`);
        
        // Check if they have free questions left
        if (user.usage_count >= 10 && user.plan_type === 'free') {
          await sendTelegramMessage(chatId, 'üö´ **NO FREE QUESTIONS LEFT!** Please upgrade to continue.');
          return;
        }
        
        const simpleResponse = await getHealthResponse(user.pending_query, {
          age: user.onboarding_info,
          language: user.language_name
        });
        
        const questionNum = user.usage_count + 1;
        const remainingQuestions = Math.max(0, 10 - questionNum);
        const responseWithUsage = `üìã **QUESTION #${questionNum}**\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n${simpleResponse}\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüìä **${remainingQuestions} free questions remaining**`;
        
        await sendTelegramMessage(chatId, responseWithUsage);
        await updateUserState(chatId, { 
          state: 'ready',
          pending_query: null,
          usage_count: questionNum
        });
      }
    } else if (data.startsWith('more_aushadhi_')) {
      // Handle "Show More" for Jan Aushadhi centers
      const parts = data.split('_');
      const pincode = parts[2];
      const offset = parseInt(parts[3]);
      await handleJanAushadhiSearch(chatId, pincode, offset);
    }
  } catch (error) {
    console.error('Error handling callback query:', error)
  }
}

async function handleOnboarding(chatId: string, messageText: string, user: User) {
  await updateUserState(chatId, {
    onboarding_info: messageText,
    state: 'ready'
  })
  
  const welcomeMessages: Record<string, string> = {
    'hi': '‚úÖ **‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶!** üéâ\n\nü©∫ **‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§™‡•ç‡§∞‡§∂‡•ç‡§® ‡§™‡•Ç‡§õ‡•á‡§Ç**\n\n**üìã ‡§Æ‡•á‡§®‡•Ç ‡§µ‡§ø‡§ï‡§≤‡•ç‡§™:**\nüí¨ /health - ‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§™‡•ç‡§∞‡§∂‡•ç‡§®\nüíä /janaushadhi - ‡§¶‡§µ‡§æ ‡§ï‡•Ä ‡§¶‡•Å‡§ï‡§æ‡§®\nüì∏ /scan - ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü ‡§∏‡•ç‡§ï‡•à‡§®\nüåê /lang - ‡§≠‡§æ‡§∑‡§æ ‡§¨‡§¶‡§≤‡•á‡§Ç',
    'ta': '‚úÖ **‡Æ®‡Æ©‡Øç‡Æ±‡Æø!** üéâ\n\nü©∫ **‡Æâ‡Æü‡Æ≤‡Øç‡Æ®‡Æ≤‡ÆÆ‡Øç ‡Æ™‡Æ±‡Øç‡Æ±‡Æø ‡Æï‡Øá‡Æ≥‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç**\n\n**üìã ‡ÆÆ‡ØÜ‡Æ©‡ØÅ ‡Æµ‡Æø‡Æ∞‡ØÅ‡Æ™‡Øç‡Æ™‡Æô‡Øç‡Æï‡Æ≥‡Øç:**\nüí¨ /health - ‡Æâ‡Æü‡Æ≤‡Øç‡Æ®‡Æ≤ ‡Æï‡Øá‡Æ≥‡Øç‡Æµ‡Æø\nüíä /janaushadhi - ‡ÆÆ‡Æ∞‡ØÅ‡Æ®‡Øç‡Æ§‡ØÅ ‡Æï‡Æü‡Øà\nüì∏ /scan - ‡ÆÖ‡Æ±‡Æø‡Æï‡Øç‡Æï‡Øà ‡Æ∏‡Øç‡Æï‡Øá‡Æ©‡Øç\nüåê /lang - ‡ÆÆ‡Øä‡Æ¥‡Æø ‡ÆÆ‡Ææ‡Æ±‡Øç‡Æ±‡ØÅ',
    'te': '‚úÖ **‡∞ß‡∞®‡±ç‡∞Ø‡∞µ‡∞æ‡∞¶‡∞æ‡∞≤‡±Å!** üéâ\n\nü©∫ **‡∞Ü‡∞∞‡±ã‡∞ó‡±ç‡∞Ø ‡∞™‡±ç‡∞∞‡∞∂‡±ç‡∞®‡∞≤‡±Å ‡∞Ö‡∞°‡∞ó‡∞Ç‡∞°‡∞ø**\n\n**üìã ‡∞Æ‡±Ü‡∞®‡±Ç ‡∞é‡∞Ç‡∞™‡∞ø‡∞ï‡∞≤‡±Å:**\nüí¨ /health - ‡∞Ü‡∞∞‡±ã‡∞ó‡±ç‡∞Ø ‡∞™‡±ç‡∞∞‡∞∂‡±ç‡∞®\nüíä /janaushadhi - ‡∞Æ‡∞Ç‡∞¶‡±Å‡∞≤ ‡∞¶‡±Å‡∞ï‡∞æ‡∞£‡∞Ç\nüì∏ /scan - ‡∞∞‡∞ø‡∞™‡±ã‡∞∞‡±ç‡∞ü‡±ç ‡∞∏‡±ç‡∞ï‡∞æ‡∞®‡±ç\nüåê /lang - ‡∞≠‡∞æ‡∞∑ ‡∞Æ‡∞æ‡∞∞‡±ç‡∞ö‡±Å',
    'kn': '‚úÖ **‡≤ß‡≤®‡≥ç‡≤Ø‡≤µ‡≤æ‡≤¶‡≤ó‡≤≥‡≥Å!** üéâ\n\nü©∫ **‡≤Ü‡≤∞‡≥ã‡≤ó‡≥ç‡≤Ø ‡≤™‡≥ç‡≤∞‡≤∂‡≥ç‡≤®‡≥Ü‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤ï‡≥á‡≤≥‡≤ø**\n\n**üìã ‡≤Æ‡≥Ü‡≤®‡≥Å ‡≤Ü‡≤Ø‡≥ç‡≤ï‡≥Ü‡≤ó‡≤≥‡≥Å:**\nüí¨ /health - ‡≤Ü‡≤∞‡≥ã‡≤ó‡≥ç‡≤Ø ‡≤™‡≥ç‡≤∞‡≤∂‡≥ç‡≤®‡≥Ü\nüíä /janaushadhi - ‡≤î‡≤∑‡≤ß‡≤ø ‡≤Ö‡≤Ç‡≤ó‡≤°‡≤ø\nüì∏ /scan - ‡≤µ‡≤∞‡≤¶‡≤ø ‡≤∏‡≥ç‡≤ï‡≥ç‡≤Ø‡≤æ‡≤®‡≥ç\nüåê /lang - ‡≤≠‡≤æ‡≤∑‡≥Ü ‡≤¨‡≤¶‡≤≤‡≤ø‡≤∏‡≤ø',
    'ml': '‚úÖ **‡¥®‡¥®‡µç‡¥¶‡¥ø!** üéâ\n\nü©∫ **‡¥Ü‡¥∞‡µã‡¥ó‡µç‡¥Ø ‡¥ö‡µã‡¥¶‡µç‡¥Ø‡¥ô‡µç‡¥ô‡µæ ‡¥ö‡µã‡¥¶‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï**\n\n**üìã ‡¥Æ‡µÜ‡¥®‡µÅ ‡¥ì‡¥™‡µç‡¥∑‡¥®‡µÅ‡¥ï‡µæ:**\nüí¨ /health - ‡¥Ü‡¥∞‡µã‡¥ó‡µç‡¥Ø ‡¥ö‡µã‡¥¶‡µç‡¥Ø‡¥Ç\nüíä /janaushadhi - ‡¥Æ‡¥∞‡µÅ‡¥®‡µç‡¥®‡µç ‡¥ï‡¥ü\nüì∏ /scan - ‡¥±‡¥ø‡¥™‡µç‡¥™‡µã‡µº‡¥ü‡µç‡¥ü‡µç ‡¥∏‡µç‡¥ï‡¥æ‡µª\nüåê /lang - ‡¥≠‡¥æ‡¥∑ ‡¥Æ‡¥æ‡¥±‡µç‡¥±‡µÅ‡¥ï',
    'bn': '‚úÖ **‡¶ß‡¶®‡ßç‡¶Ø‡¶¨‡¶æ‡¶¶!** üéâ\n\nü©∫ **‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶ú‡¶ø‡¶ú‡ßç‡¶û‡¶æ‡¶∏‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®**\n\n**üìã ‡¶Æ‡ßá‡¶®‡ßÅ ‡¶Ö‡¶™‡¶∂‡¶®:**\nüí¨ /health - ‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®\nüíä /janaushadhi - ‡¶ì‡¶∑‡ßÅ‡¶ß‡ßá‡¶∞ ‡¶¶‡ßã‡¶ï‡¶æ‡¶®\nüì∏ /scan - ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü ‡¶∏‡ßç‡¶ï‡ßç‡¶Ø‡¶æ‡¶®\nüåê /lang - ‡¶≠‡¶æ‡¶∑‡¶æ ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶®',
    'gu': '‚úÖ **‡™Ü‡™≠‡™æ‡™∞!** üéâ\n\nü©∫ **‡™Ü‡™∞‡´ã‡™ó‡´ç‡™Ø ‡™™‡´ç‡™∞‡™∂‡´ç‡™®‡´ã ‡™™‡´Ç‡™õ‡´ã**\n\n**üìã ‡™Æ‡´á‡™®‡´Å ‡™µ‡™ø‡™ï‡™≤‡´ç‡™™‡´ã:**\nüí¨ /health - ‡™Ü‡™∞‡´ã‡™ó‡´ç‡™Ø ‡™™‡´ç‡™∞‡™∂‡´ç‡™®\nüíä /janaushadhi - ‡™¶‡™µ‡™æ‡™®‡´Ä ‡™¶‡´Å‡™ï‡™æ‡™®\nüì∏ /scan - ‡™∞‡™ø‡™™‡´ã‡™∞‡´ç‡™ü ‡™∏‡´ç‡™ï‡´á‡™®\nüåê /lang - ‡™≠‡™æ‡™∑‡™æ ‡™¨‡™¶‡™≤‡´ã',
    'mr': '‚úÖ **‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶!** üéâ\n\nü©∫ **‡§Ü‡§∞‡•ã‡§ó‡•ç‡§Ø ‡§™‡•ç‡§∞‡§∂‡•ç‡§® ‡§µ‡§ø‡§ö‡§æ‡§∞‡§æ**\n\n**üìã ‡§Æ‡•á‡§®‡•Ç ‡§™‡§∞‡•ç‡§Ø‡§æ‡§Ø:**\nüí¨ /health - ‡§Ü‡§∞‡•ã‡§ó‡•ç‡§Ø ‡§™‡•ç‡§∞‡§∂‡•ç‡§®\nüíä /janaushadhi - ‡§î‡§∑‡§ß ‡§¶‡•Å‡§ï‡§æ‡§®\nüì∏ /scan - ‡§Ö‡§π‡§µ‡§æ‡§≤ ‡§∏‡•ç‡§ï‡•Ö‡§®\nüåê /lang - ‡§≠‡§æ‡§∑‡§æ ‡§¨‡§¶‡§≤‡§æ',
    'pa': '‚úÖ **‡®ß‡©∞‡®®‡®µ‡®æ‡®¶!** üéâ\n\nü©∫ **‡®∏‡®ø‡®π‡®§ ‡®∏‡®µ‡®æ‡®≤ ‡®™‡©Å‡©±‡®õ‡©ã**\n\n**üìã ‡®Æ‡©Ä‡®®‡©Ç ‡®µ‡®ø‡®ï‡®≤‡®™:**\nüí¨ /health - ‡®∏‡®ø‡®π‡®§ ‡®∏‡®µ‡®æ‡®≤\nüíä /janaushadhi - ‡®¶‡®µ‡®æ‡®à ‡®¶‡©Å‡®ï‡®æ‡®®\nüì∏ /scan - ‡®∞‡®ø‡®™‡©ã‡®∞‡®ü ‡®∏‡®ï‡©à‡®®\nüåê /lang - ‡®≠‡®æ‡®∏‡®º‡®æ ‡®¨‡®¶‡®≤‡©ã',
    'en': '‚úÖ **THANK YOU!** üéâ\n\nü©∫ **ASK HEALTH QUESTIONS**\n\n**üìã MENU OPTIONS:**\nüí¨ /health - Ask health question\nüíä /janaushadhi - Find medicine stores\nüì∏ /scan - Scan medical reports\nüåê /lang - Change language'
  };
  
  const welcomeMsg = welcomeMessages[user.language] || welcomeMessages['en'];
  
  // Send menu with reply keyboard
  const keyboard = {
    keyboard: [
      [{ text: 'üí¨ Health Question' }, { text: 'üíä Find Medicine Store' }],
      [{ text: 'üì∏ Scan Report' }, { text: 'üåê Language' }]
    ],
    resize_keyboard: true,
    persistent: true
  };
  
  await sendTelegramMessage(chatId, welcomeMsg, { reply_markup: keyboard })
}

async function handleLanguageChange(chatId: string, user: User) {
  await updateUserState(chatId, { 
    state: 'language_selection',
    language: '',
    language_name: '',
    pending_query: null
  })
  const keyboard = getLanguageInlineKeyboard()
  await sendTelegramMessage(chatId, getLanguageSelectionMessage(), keyboard)
}

// Payment handling
async function handlePaymentRequest(chatId: string, query: string, user: User, isVoice = false, isImage = false) {
  console.log(`üí∞ PAYMENT REQUEST TRIGGERED`);
  console.log(`User: ${chatId}, Free used: ${user.free_complex_used}`);
  
  // Clear context for fresh response
  await clearUserContext(chatId);
  
  if (!user.free_complex_used) {
    // First complex diagnosis is free
    console.log(`üÜì Providing FREE complex diagnosis for user ${chatId}`);
    const analysisType = isVoice ? 'üé§ Voice + AI Medical Panel' : isImage ? 'üì∏ Image + AI Medical Panel' : 'ü§ñ AI Medical Panel';
    await sendTelegramMessage(chatId, `üÜì FREE Complex Diagnosis\n\n${analysisType} analysis...`);
    
    console.log(`ü§ñ Starting MAI-DxO orchestrator for query: "${query}"`);
    const diagnosis = await maiDxoOrchestrator(query, {
      age: user.onboarding_info,
      language: user.language_name,
      isFirstFree: true,
      isVoice,
      isImage
    });
    
    // For voice queries, also send audio response
    if (isVoice && user.language !== 'en') {
      try {
        const translatedResponse = await translateText(diagnosis, 'en', user.language);
        const audioBuffer = await generateAudio(translatedResponse, user.language);
        await sendTelegramAudio(chatId, audioBuffer, translatedResponse);
      } catch (error) {
        console.error('Voice response error:', error);
        await sendTelegramMessage(chatId, diagnosis);
      }
    } else {
      await sendTelegramMessage(chatId, diagnosis);
    }
    
    await updateUserState(chatId, { 
      free_complex_used: true,
      paid_complex_count: 0
    });
    console.log(`‚úÖ Free complex diagnosis completed for user ${chatId}`);
  } else {
    // Paid diagnosis required
    console.log(`üí≥ Requesting payment for user ${chatId}`);
    await sendTelegramMessage(chatId, 
      `üí∞ **COMPLEX AI DIAGNOSIS - ‚Çπ500**\n\nüî¨ **ADVANCED MULTI-AI MEDICAL PANEL ANALYSIS**\nüìä **DIFFERENTIAL DIAGNOSIS WITH PROBABILITY RANKING**\nü©∫ **OPTIMIZED TEST RECOMMENDATIONS**\nüí° **COST-EFFECTIVE CARE PATHWAY**\n\n**üëá CHOOSE AN OPTION:**`,
      {
        inline_keyboard: [
          [{ text: "üí≥ **PAY ‚Çπ500 FOR FULL ANALYSIS**", url: "https://razorpay.me/@movemtechnologiesprivatelimit?amount=50000" }],
          [{ text: "üí¨ **GET BASIC GUIDANCE (FREE)**", callback_data: "skip_payment" }]
        ]
      }
    );
    
    // Set user state to awaiting payment
    await updateUserState(chatId, { state: 'awaiting_payment', pending_query: query });
  }
}

async function handlePaymentVerification(chatId: string, user: User) {
  if (user.state === 'awaiting_payment' && user.pending_query) {
    await sendTelegramMessage(chatId, 
      `‚úÖ Payment received! Analyzing with AI medical panel...`
    );
    
    const diagnosis = await maiDxoOrchestrator(user.pending_query, {
      age: user.onboarding_info,
      language: user.language_name,
      isPaid: true
    });
    
    await sendTelegramMessage(chatId, diagnosis);
    await updateUserState(chatId, { 
      state: 'ready',
      pending_query: null,
      paid_complex_count: (user.paid_complex_count || 0) + 1
    });
  }
}

async function handleHealthQuery(chatId: string, messageText: string, user: User) {
  try {
    console.log(`üìù HEALTH QUERY RECEIVED from ${chatId}: "${messageText}"`);
    console.log(`User stats: ${user.usage_count}/10 free questions, Plan: ${user.plan_type}`);
    
    // Check usage limits for simple queries
    if (user.usage_count >= 10 && user.plan_type === 'free') {
      await sendTelegramMessage(chatId, 
        `üö´ **FREE QUESTIONS EXHAUSTED!**\n\n‚úÖ **You've used all 10 free questions**\n\nüí≥ **UPGRADE OPTIONS:**\n\nüì± **‚Çπ100/month** - Unlimited simple questions\nü§ñ **‚Çπ200/question** - Complex AI diagnosis\n\n**üëá CHOOSE:**`,
        {
          inline_keyboard: [
            [{ text: "üí≥ **PAY ‚Çπ100/MONTH UNLIMITED**", url: "https://razorpay.me/@movemtechnologiesprivatelimit?amount=10000" }],
            [{ text: "ü§ñ **PAY ‚Çπ200 COMPLEX DIAGNOSIS**", callback_data: "pay_complex" }]
          ]
        }
      );
      await updateUserState(chatId, { state: 'awaiting_subscription', pending_query: messageText });
      return;
    }
    
    // Clear context for fresh response
    await clearUserContext(chatId);
    
    const userContext = {
      age: user.onboarding_info,
      language: user.language_name,
      previous_conversations: [],
      timestamp: Date.now()
    }
    
    // Check if complex diagnosis is needed
    if (shouldUseMaiDxo(messageText, false, false, user)) {
      console.log(`üöÄ Routing to COMPLEX diagnosis (‚Çπ200)`);
      await sendTelegramMessage(chatId, 
        `ü§ñ **COMPLEX DIAGNOSIS REQUIRED - ‚Çπ200**\n\nüî¨ **ADVANCED MULTI-AI ANALYSIS**\nüìä **DETAILED DIAGNOSIS**\nüí° **PERSONALIZED RECOMMENDATIONS**\n\n**üëá CHOOSE:**`,
        {
          inline_keyboard: [
            [{ text: "üí≥ **PAY ‚Çπ200 FOR ANALYSIS**", url: "https://razorpay.me/@movemtechnologiesprivatelimit?amount=20000" }],
            [{ text: "üí¨ **GET BASIC ANSWER (FREE)**", callback_data: "use_simple" }]
          ]
        }
      );
      await updateUserState(chatId, { state: 'awaiting_complex_payment', pending_query: messageText });
      return;
    }
    
    // Simple health query - use Claude only
    console.log(`üí¨ Routing to SIMPLE diagnosis (Claude only)`);
    const healthResponse = await getHealthResponse(messageText, userContext);
    
    const questionNum = user.usage_count + 1;
    const remainingQuestions = Math.max(0, 10 - questionNum);
    
    const responseWithUsage = `üìã **QUESTION #${questionNum}**\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n${healthResponse}\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüìä **${remainingQuestions} free questions remaining**`;
    
    await sendTelegramMessage(chatId, responseWithUsage);
    
    const now = new Date().toISOString();
    await updateUserState(chatId, {
      last_used: now,
      usage_count: questionNum
    });
    console.log(`‚úÖ Simple diagnosis completed for user ${chatId} (${questionNum}/10)`);
    
  } catch (error) {
    console.error('Error handling health query:', error);
    const errorMsg = user.language === 'hi'
      ? '‚ùå **‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§π‡•Å‡§à!** ‡§ï‡•É‡§™‡§Ø‡§æ ‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡•á‡§Ç‡•§'
      : '‚ùå **ERROR!** Please try again.';
    
    await sendTelegramMessage(chatId, errorMsg);
  }
}

async function handleVoiceMessage(chatId: string, voice: any, user: User) {
  try {
    console.log(`üé§ Voice message received from ${chatId}`);
    
    // Check if user has microphone access
    await sendTelegramMessage(chatId, 'üé§ **PROCESSING YOUR VOICE MESSAGE...**\n\n‚ö†Ô∏è **If you cannot record voice:**\nüîä **Enable microphone permission**\nüì± **Check phone settings**');
    
    // Download voice file
    const voiceUrl = await downloadTelegramFile(voice.file_id);
    
    // Transcribe using Sarvam STT
    const transcript = await transcribeAudio(voiceUrl, user.language);
    
    // Translate to English if needed
    let englishQuery = transcript;
    if (user.language !== 'en') {
      englishQuery = await translateText(transcript, user.language, 'en');
    }
    
    console.log(`üé§ Voice transcript: "${transcript}" ‚Üí "${englishQuery}"`);
    
    await sendTelegramMessage(chatId, `üé§ **HEARD YOU SAY:** "${transcript}"\n\nü§ñ **ANALYZING...** Please wait...`);
    
    // Voice always triggers complex diagnosis
    console.log(`üöÄ Voice routing to COMPLEX diagnosis (MAI-DxO)`);
    await handlePaymentRequest(chatId, englishQuery, user, true, false);
    
  } catch (error) {
    console.error('Error handling voice message:', error);
    const msg = user.language === 'hi'
      ? '‚ùå **‡§µ‡•â‡§á‡§∏ ‡§™‡•ç‡§∞‡•ã‡§∏‡•á‡§∏‡§ø‡§Ç‡§ó ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ!**\n\nüîß **‡§ï‡•É‡§™‡§Ø‡§æ ‡§∏‡•Å‡§®‡§ø‡§∂‡•ç‡§ö‡§ø‡§§ ‡§ï‡§∞‡•á‡§Ç:**\nüé§ **‡§Æ‡§æ‡§á‡§ï‡•ç‡§∞‡•ã‡§´‡•ã‡§® ‡§ö‡§æ‡§≤‡•Ç ‡§π‡•à**\nüîä **‡§Ü‡§µ‡§æ‡§ú‡§º ‡§∏‡§æ‡§´‡§º ‡§π‡•à**\nüì± **‡§®‡•á‡§ü‡§µ‡§∞‡•ç‡§ï ‡§ï‡§®‡•á‡§ï‡•ç‡§∂‡§® ‡§†‡•Ä‡§ï ‡§π‡•à**\n\nüîÑ **‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡•á‡§Ç**'
      : '‚ùå **VOICE PROCESSING ERROR!**\n\nüîß **PLEASE CHECK:**\nüé§ **MICROPHONE IS ENABLED**\nüîä **SPEAK CLEARLY**\nüì± **NETWORK CONNECTION IS GOOD**\n\nüîÑ **TRY AGAIN**';
    
    await sendTelegramMessage(chatId, msg);
  }
}

async function handleImageMessage(chatId: string, photo: any, user: User) {
  try {
    console.log(`üì∏ Image message received from ${chatId}`);
    
    // For now, treat as complex medical scan/document
    const imageQuery = "Medical image/scan analysis requested";
    
    await sendTelegramMessage(chatId, 'üì∏ Processing your medical image...');
    
    // Images always trigger complex diagnosis
    console.log(`üöÄ Image routing to COMPLEX diagnosis (MAI-DxO)`);
    await handlePaymentRequest(chatId, imageQuery, user, false, true);
    
  } catch (error) {
    console.error('Error handling image message:', error);
    const msg = user.language === 'hi'
      ? '‡§á‡§Æ‡•á‡§ú ‡§™‡•ç‡§∞‡•ã‡§∏‡•á‡§∏ ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§π‡•Å‡§à‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡•á‡§Ç‡•§'
      : 'Error processing image. Please try again.';
    
    await sendTelegramMessage(chatId, msg);
  }
}

// Webhook handler
async function handleTelegramUpdate(update: TelegramUpdate) {
  // Handle callback queries (button presses)
  if (update.callback_query) {
    await handleCallbackQuery(update.callback_query)
    return
  }
  
  if (!update.message) return
  
  const chatId = update.message.chat.id.toString()
  const messageText = update.message.text
  const voice = update.message.voice
  const photo = update.message.photo
  const document = update.message.document
  
  console.log(`Message from ${chatId}: ${messageText || voice ? 'voice' : photo ? 'photo' : document ? 'document' : 'media'}`)
  
  try {
    const user = await getOrCreateUser(chatId)
    
    // Handle voice messages
    if (voice) {
      await handleVoiceMessage(chatId, voice, user)
      return
    }
    
    // Handle photo messages
    if (photo && photo.length > 0) {
      await handleImageMessage(chatId, photo, user)
      return
    }
    
    // Handle document messages (scans, reports)
    if (document) {
      await handleImageMessage(chatId, document, user)
      return
    }
    
    // Handle text messages
    if (!messageText) return
    
    // Handle different user states
    switch (user.state) {
      case 'language_selection':
        await handleLanguageSelection(chatId, messageText, user)
        break
        
      case 'onboarding':
        await handleOnboarding(chatId, messageText, user)
        break
        
      case 'ready':
        // Handle keyboard button presses
        if (messageText === 'üí¨ Health Question' || messageText.toLowerCase() === '/health') {
          await sendTelegramMessage(chatId, 'ü©∫ **ASK YOUR HEALTH QUESTION:**\n\nType your symptoms or health concern...');
        } else if (messageText === 'üíä Find Medicine Store' || messageText.startsWith('/janaushadhi')) {
          const pincode = messageText.replace('/janaushadhi', '').replace('üíä Find Medicine Store', '').trim();
          if (pincode && pincode.length === 6 && /^\d+$/.test(pincode)) {
            await handleJanAushadhiSearch(chatId, pincode);
          } else {
            await sendTelegramMessage(chatId, 'üíä **FIND JAN AUSHADHI STORES**\n\nüìç **Enter your 6-digit pincode:**\n\nExample: 110001');
          }
        } else if (messageText === 'üì∏ Scan Report' || messageText.toLowerCase() === '/scan') {
          await sendTelegramMessage(chatId, 'üì∏ **SCAN MEDICAL REPORT**\n\nüì∑ **Send photo of your:**\n‚Ä¢ Lab reports\n‚Ä¢ Prescription\n‚Ä¢ Medical documents\n\nüî¨ **We\'ll analyze it for FREE!**');
        } else if (messageText === 'üåê Language' || messageText.toLowerCase() === 'lang' || messageText === '/lang') {
          await handleLanguageChange(chatId, user);
        } else if (messageText.toLowerCase() === '/menu' || messageText === '/help') {
          await showMainMenu(chatId, user);
        } else if (/^\d{6}$/.test(messageText.trim())) {
          // Direct pincode entry
          await handleJanAushadhiSearch(chatId, messageText.trim());
        } else {
          await handleHealthQuery(chatId, messageText, user);
        }
        break
        
      case 'awaiting_subscription':
        if (messageText.toLowerCase().includes('paid') || messageText.toLowerCase().includes('screenshot') || messageText.toLowerCase().includes('done')) {
          await sendTelegramMessage(chatId, '‚úÖ **SUBSCRIPTION ACTIVATED!**\n\nüéâ **UNLIMITED SIMPLE QUESTIONS**');
          await updateUserState(chatId, { 
            state: 'ready',
            plan_type: 'premium',
            pending_query: null
          });
        } else {
          // Auto-reset if user sends new message
          await sendTelegramMessage(chatId, 'üîÑ **Starting fresh session...**');
          await updateUserState(chatId, { state: 'ready', pending_query: null });
          await handleHealthQuery(chatId, messageText, user);
        }
        break
        
      case 'awaiting_complex_payment':
        if (messageText.toLowerCase().includes('paid') || messageText.toLowerCase().includes('screenshot') || messageText.toLowerCase().includes('done')) {
          if (user.pending_query) {
            await sendTelegramMessage(chatId, '‚úÖ **PAYMENT RECEIVED!** Analyzing with AI medical panel...');
            
            const diagnosis = await maiDxoOrchestrator(user.pending_query, {
              age: user.onboarding_info,
              language: user.language_name,
              isPaid: true
            });
            
            await sendTelegramMessage(chatId, diagnosis);
            await updateUserState(chatId, { 
              state: 'ready',
              pending_query: null,
              paid_complex_count: (user.paid_complex_count || 0) + 1
            });
          }
        } else {
          // Auto-reset if user sends new message
          await sendTelegramMessage(chatId, 'üîÑ **Starting fresh session...**');
          await updateUserState(chatId, { state: 'ready', pending_query: null });
          await handleHealthQuery(chatId, messageText, user);
        }
        break
        
      default:
        // New user or reset - show language selection with keyboard
        await updateUserState(chatId, { state: 'language_selection' })
        const keyboard = getLanguageInlineKeyboard()
        await sendTelegramMessage(chatId, getLanguageSelectionMessage(), keyboard)
        break
    }
  } catch (error) {
    console.error('Error handling update:', error)
    await sendTelegramMessage(chatId, 'Sorry, something went wrong. Please try again.')
  }
}

// Main Edge Function
serve(async (req) => {
  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'POST, GET, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization'
  }
  
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }
  
  if (req.method === 'GET') {
    // Setup bot commands on startup
    await setupBotCommands();
    
    return new Response(JSON.stringify({ 
      status: 'Dr247Bot is running!', 
      timestamp: new Date().toISOString() 
    }), {
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    })
  }
  
  try {
    const update: TelegramUpdate = await req.json()
    console.log('Received update:', JSON.stringify(update))
    
    await handleTelegramUpdate(update)
    
    return new Response('OK', { status: 200, headers: corsHeaders })
    
  } catch (error) {
    console.error('Webhook error:', error)
    return new Response('Error processing update', { status: 500, headers: corsHeaders })
  }
})

// Setup bot commands
async function setupBotCommands() {
  try {
    const commands = [
      { command: 'start', description: 'üè• Start health consultation' },
      { command: 'health', description: 'üí¨ Ask health question' },
      { command: 'janaushadhi', description: 'üíä Find Jan Aushadhi stores' },
      { command: 'scan', description: 'üì∏ Scan medical reports' },
      { command: 'menu', description: 'üìã Show main menu' },
      { command: 'lang', description: 'üåê Change language' },
      { command: 'help', description: '‚ùì Get help' }
    ];

    await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/setMyCommands`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ commands })
    });
    
    console.log('‚úÖ Bot commands registered');
  } catch (error) {
    console.error('Failed to setup commands:', error);
  }
}